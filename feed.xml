<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sungrinhan.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sungrinhan.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-05T12:45:32+00:00</updated><id>https://sungrinhan.github.io/feed.xml</id><title type="html">성린s 메모장</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html"></title><link href="https://sungrinhan.github.io/blog/2025/2025-04-28-%EC%A3%BC%EC%A0%9C-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4-%ED%96%A5%EC%83%81%EA%B3%BC-seo-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A1%9C-%EB%A6%AC%EB%8D%94%ED%95%9C-%EA%B1%B8%EC%9D%8C-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0/" rel="alternate" type="text/html" title=""/><published>2025-05-05T12:45:32+00:00</published><updated>2025-05-05T12:45:32+00:00</updated><id>https://sungrinhan.github.io/blog/2025/2025-04-28-%EC%A3%BC%EC%A0%9C:-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering:-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4-%ED%96%A5%EC%83%81%EA%B3%BC-seo-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A1%9C-%EB%A6%AC%EB%8D%94%ED%95%9C-%EA%B1%B8%EC%9D%8C-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/2025-04-28-%EC%A3%BC%EC%A0%9C-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-next.js%EC%97%90%EC%84%9C%EC%9D%98-server-side-rendering-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4-%ED%96%A5%EC%83%81%EA%B3%BC-seo-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A1%9C-%EB%A6%AC%EB%8D%94%ED%95%9C-%EA%B1%B8%EC%9D%8C-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0/"><![CDATA[<h1 id="nextjs에서의-server-side-rendering-퍼포먼스-향상과-seo-최적화로-리더한-걸음-더-나아가기">Next.js에서의 Server Side Rendering: 퍼포먼스 향상과 SEO 최적화로 리더한 걸음 더 나아가기</h1> <p>Next.js는 JavaScript 언어를 사용하여 서버 사이드 렌더링(SSR)이 가능한 어플리케이션을 만들때 많이 쓰이는 프레임워크입니다. 플랫폼 독립적이며 React 기반의 프레임워크로서, Webpack과 Bable 등의 환경 설정 없이 효과적인 서버 사이드 렌더링이 가능합니다.</p> <p>그렇다면 왜 Next.js에서의 서버 사이드 렌더링이 중요한 것일까요? 이는 주로 퍼포먼스 향상과 SEO 최적화에 직결되기 때문입니다.</p> <p>일반적인 클라이언트 사이드 렌더링은 첫 페이지 로딩 시간이 길고, 검색 엔진 최적화가 어렵다는 단점을 가지고 있습니다. 그러나 서버 사이드 렌더링을 사용하면 이러한 문제를 해결할 수 있습니다. 서버에서 렌더링된 페이지는 브라우저에 바로 표시되므로 사용자는 빠른 페이지 로드 시간을 경험할 수 있으며, 검색 엔진이 페이지 컨텐츠를 이해하고 처리할 수 있어 SEO에 유리합니다.</p> <p>Next.js에서는 <code class="language-plaintext highlighter-rouge">getServerSideProps</code> 함수를 이용해 데이터를 미리 가져오고, 이를 이용해 동적 라우팅과 서버 사이드 렌더링을 할 수 있습니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">getServerSideProps</span><span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="s2">`https://.../data`</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">()</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">notFound</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span> <span class="p">},</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">Page</span><span class="p">({</span> <span class="nx">data</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Render data...</span>
<span class="p">}</span>
</code></pre></div></div> <p>위 코드에서 볼 수 있듯, <code class="language-plaintext highlighter-rouge">getServerSideProps</code>는 페이지에 필요한 데이터를 가져오는 역할을 합니다. 이 함수에는 페이지의 context 인자가 제공되며,이를 통해 route parameters, query strings 등의 데이터에 접근할 수 있습니다.</p> <p>Next.js에서는 각 페이지 요청 시마다 <code class="language-plaintext highlighter-rouge">getServerSideProps</code> 가 호출되므로, 항상 최신의 데이터를 제공할 수 있습니다. 이는 ecommerce 사이트에서 재고의 변화를 실시간으로 반영하거나, 블로그 게시글의 댓글 등 동적인 데이터를 사용하는 경우에 유용합니다.</p> <p>하지만 모든 페이지에서 모든 데이터를 미리 불러오는 것은 서버 부하의 원인이 될 수 있으므로, 필요할 때만 SSR을 이용하고 그 외의 경우에는 Static Generation 혹은 Client Side Rendering을 고려하는 것이 좋습니다.</p> <p>생각해보면, Next.js의 이러한 특징을 이용하면 로그인 기반의 컨텐츠를 제공하는 경우에도 효과적으로 사용할 수 있습니다. 예를들면, 사용자의 로그인 상태에 따라 페이지 내용이 변하는 경우, <code class="language-plaintext highlighter-rouge">getServerSideProps</code>에서 로그인 상태를 확인하고 이에 맞는 데이터를 불러오는 방식으로 구현할 수 있습니다. 이를 통해 사용자 별 맞춤화된 페이지를 빠르게 제공할 수 있게 됩니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">getServerSideProps</span><span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">req</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">context</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">session</span> <span class="o">=</span> <span class="nf">getSession</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">session</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">redirect</span><span class="p">:</span> <span class="p">{</span>
        <span class="c1">//로그인 상태가 아니면 로그인 페이지로 리다이렉트</span>
        <span class="na">destination</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/login</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">permanent</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//이하 로그인 상태일 때의 데이터 로드 로직</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>앞서 설명드린 것처럼 Next.js의 SSR은 퍼포먼스 향상 및 SEO 최적화 뿐만 아니라, 높은 수준의 커스터마이즈 역시 가능하게 합니다. 이를 활용하여 사용자 중심의 최적화된 웹 어플리케이션을 구축해보세요.</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https://sungrinhan.github.io/blog/2025/2025-05-01-%EC%A3%BC%EC%A0%9C-redux%EC%99%80-typescript%EC%9D%98-%EC%97%B0%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-redux%EC%99%80-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8D%94-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C/" rel="alternate" type="text/html" title=""/><published>2025-05-05T12:45:32+00:00</published><updated>2025-05-05T12:45:32+00:00</updated><id>https://sungrinhan.github.io/blog/2025/2025-05-01-%EC%A3%BC%EC%A0%9C:-redux%EC%99%80-typescript%EC%9D%98-%EC%97%B0%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-redux%EC%99%80-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8D%94-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/2025-05-01-%EC%A3%BC%EC%A0%9C-redux%EC%99%80-typescript%EC%9D%98-%EC%97%B0%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-redux%EC%99%80-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8D%94-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C/"><![CDATA[<hr/> <p>Redux와 TypeScript를 함께 사용하면 상태 관리를 더욱 강화하고 안정적으로 할 수 있습니다. Redux는 JavaScript 애플리케이션에서 상태를 예측 가능하게 관리하기 위한 라이브러리이며, TypeScript는 자바스크립트의 슈퍼셋으로, 정적 타입으로 코드의 안정성을 높여주는 언어입니다.</p> <p>Redux의 핵심 기능 중 하나는 애플리케이션의 상태를 중앙 집중식으로 관리한다는 것입니다. 이는 개발자들이 애플리케이션의 상태 변화를 예측하고 이해하기 쉽게 해주며, 하나의 저장소에서 애플리케이션 상태를 관리하므로 코드의 복잡성을 줄여줍니다.</p> <p>TypeScript는 자료형을 사용하여 변수, 함수 매개변수, 반환값에 대한 정보를 제공하여, 복잡한 코드를 이해하는 데 도움을 줍니다. 또한, 자료형 오류를 컴파일 단계에서 잡아냄으로써 런타임 오류를 방지해줍니다. 따라서, Redux와 TypeScript를 함께 사용하면, 동적인 JavaScript 언어의 유연성과 정적 자료형의 안정성을 동시에 얻을 수 있습니다.</p> <p>이제 Redux와 TypeScript를 연계하여 사용하는 실제 코드 예시를 볼 것입니다.</p> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// actions.ts</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createAction</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">addTodo</span> <span class="o">=</span> <span class="nx">createAction</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">todos/add</span><span class="dl">'</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">toggleTodo</span> <span class="o">=</span> <span class="nx">createAction</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">todos/toggle</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// reducer.ts</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createReducer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">addTodo</span><span class="p">,</span> <span class="nx">toggleTodo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./actions</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kr">interface</span> <span class="nx">Todo</span> <span class="p">{</span>
  <span class="nl">text</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">completed</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">TodosState</span> <span class="p">{</span>
  <span class="nl">todos</span><span class="p">:</span> <span class="nx">Todo</span><span class="p">[];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">initialState</span><span class="p">:</span> <span class="nx">TodosState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">todos</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">todosReducer</span> <span class="o">=</span> <span class="nf">createReducer</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="p">(</span><span class="nx">builder</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">builder</span>
    <span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">addTodo</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span> <span class="na">text</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">,</span> <span class="na">completed</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">toggleTodo</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">todo</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">[</span><span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">];</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">todo</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">todo</span><span class="p">.</span><span class="nx">completed</span> <span class="o">=</span> <span class="o">!</span><span class="nx">todo</span><span class="p">.</span><span class="nx">completed</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <p>위 코드에서는 액션 생성 함수<code class="language-plaintext highlighter-rouge">createAction</code>과 리듀서 생성 함수 <code class="language-plaintext highlighter-rouge">createReducer</code>를 사용하여 Redux 액션과 리듀서를 정의하였습니다. 여기서 TypeScript의 장점을 활용하여 액션 페이로드의 타입을 지정하였고, 각 Todo 항목과 Todo 목록의 상태를 인터페이스로 정의하여 안전하게 상태를 관리하였습니다.</p> <p>실무에서는 액션 타입을 상수로 정의하고, 이를 여러 파일에서 재사용할 수 있도록 모듈로 분리하는 것이 좋습니다. 또한, 공통적으로 사용되는 상태의 형태를 인터페이스나 타입으로 정의하여 코드의 일관성을 유지하고 오류를 줄일 수 있습니다.</p> <p>음 다음은 Redux와 TypeScript를 활용하여 비동기 요청을 처리하는 응용 예제입니다.</p> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// actions.ts</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createAsyncThunk</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">fetchTodos</span> <span class="o">=</span> <span class="nf">createAsyncThunk</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">todos/fetchTodos</span><span class="dl">'</span><span class="p">,</span>
  <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://example.com/todos</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="c1">// reducer.ts</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createReducer</span><span class="p">,</span> <span class="nx">PayloadAction</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">fetchTodos</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./actions</span><span class="dl">'</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">TodosState</span> <span class="p">{</span>
  <span class="nl">todos</span><span class="p">:</span> <span class="nx">Todo</span><span class="p">[];</span>
  <span class="nl">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">idle</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">succeeded</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">error</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">initialState</span><span class="p">:</span> <span class="nx">TodosState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">todos</span><span class="p">:</span> <span class="p">[],</span>
  <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">idle</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">error</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">todosReducer</span> <span class="o">=</span> <span class="nf">createReducer</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="p">(</span><span class="nx">builder</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">builder</span>
    <span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">fetchTodos</span><span class="p">.</span><span class="nx">pending</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">fetchTodos</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="na">action</span><span class="p">:</span> <span class="nx">PayloadAction</span><span class="o">&lt;</span><span class="nx">Todo</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">succeeded</span><span class="dl">'</span><span class="p">;</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span> <span class="o">=</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">fetchTodos</span><span class="p">.</span><span class="nx">rejected</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="na">action</span><span class="p">:</span> <span class="nx">PayloadAction</span><span class="o">&lt;</span><span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">;</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">error</span> <span class="o">=</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <p>이때 서버로부터 받는 데이터의 형태를 TypeScript 타입으로 정의하면, 데이터 처리 과정에서 발생할 수 있는 오류를 줄일 수 있습니다.</p> <p>마지막으로, Redux 코드를 작성하면서 아래와 같은 습관을 갖는 것이 좋습니다. 복잡한 로직은 미들웨어나 썽크(thunk)에 배치하고, 리듀서는 순수 함수 기반으로 유지하며, 상태를 불변하게 관리하고, 셀렉터를 사용하여 상태 쿼리를 최적화하세요.</p> <p>Redux와 TypeScript의 함께 사용하는 것은 코드의 안정성과 가독성을 높여줍니다. 그러나 처음에는 셋업이 복잡하고 학습 곡선이 다소 가파르기 때문에, 사전에 Redux와 TypeScript에 대한 충분한 이해가 필요합니다.</p> <p>이 포스트는 Redux와 TypeScript의 기본적인 사용 방법에 대해 설명하였습니다. 더 다양하고 복잡한 상황에서는 공식 문서를 참고하거나, 커뮤니티에서 해결책을 찾는 것이 좋습니다.</p>]]></content><author><name></name></author></entry><entry><title type="html">React Native를 이용해 본격 크로스 플랫폼 모바일 앱 개발에 도전하기</title><link href="https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C-%EC%B6%94%EC%B2%9C-react-native%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-native%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EB%B3%B8%EA%B2%A9-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%97%90-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="React Native를 이용해 본격 크로스 플랫폼 모바일 앱 개발에 도전하기"/><published>2025-05-04T14:55:03+00:00</published><updated>2025-05-04T14:55:03+00:00</updated><id>https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C-%EC%B6%94%EC%B2%9C:-react-native%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react-native%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EB%B3%B8%EA%B2%A9-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%97%90-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C-%EC%B6%94%EC%B2%9C-react-native%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-native%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EB%B3%B8%EA%B2%A9-%ED%81%AC%EB%A1%9C%EC%8A%A4-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%97%90-%EB%8F%84%EC%A0%84%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="react-native를-이용해-본격-크로스-플랫폼-모바일-앱-개발에-도전하기">React Native를 이용해 본격 크로스 플랫폼 모바일 앱 개발에 도전하기</h1> <p>React Native는 Facebook에서 개발한 오픈 소스 모바일 애플리케이션 프레임워크입니다. 이는 웹앱의 성능을 향상시키는 React 및 JavaScript와 같은 웹 기술을 통해 iOS와 Android 어플리케이션을 동시에 개발할 수 있게 해줍니다. 이는 따라서 개발자들에게 시간과 비용을 절약하면서도 성능 면에서 손해를 보지 않게 해줍니다.</p> <p>React Native에서 특이한 점은 여기서 개발된 애플리케이션은 웹 뷰를 사용하지 않습니다. 대신 자바스크립트 코드는 기본 모듈을 통해 iOS와 Android의 네이티브 코드로 변환되어 직접 실행합니다. 이는 앱의 성능이 우수하게 유지되는 것을 보증합니다.</p> <p>그렇다면 실제로 어떻게 이루어지는지 예제 코드를 통해 살펴봅시다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">StyleSheet</span><span class="p">,</span> <span class="nx">Text</span><span class="p">,</span> <span class="nx">View</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">View</span> <span class="na">style</span><span class="p">=</span><span class="si">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">container</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello, World!<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">View</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">StyleSheet</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span>
  <span class="na">container</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">flex</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#fff</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alignItems</span><span class="p">:</span> <span class="dl">'</span><span class="s1">center</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">justifyContent</span><span class="p">:</span> <span class="dl">'</span><span class="s1">center</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div> <p>위의 코드는 가장 기본적인 “Hello, World!” 앱입니다. 여기에서는 React의 JSX 문법을 사용해 UI를 구현하고 있음을 확인할 수 있습니다. 그리고 React Native의 레이아웃 엔진인 Flexbox를 이용하여 각 요소의 배치를 설정하고 있습니다.</p> <p>실무에서 자주 이용되는 팁 중 하나는 “Hot Reloading”과 “Live Reloading” 기능인데요. 이는 프로덕션 앱에서의 버그 수정 및 새로운 기능 개발을 더 효과적으로 할 수 있게 도와줍니다. <code class="language-plaintext highlighter-rouge">Cmd + M</code> (안드로이드) 또는 <code class="language-plaintext highlighter-rouge">Cmd + D</code> (iOS)를 눌러 개발자 메뉴에 들어가면 이 두 가지 기능을 쉽게 활성화 할 수 있습니다.</p> <p>응용버전을 떠올리자면, React Native와 Redux를 이용한 상태 관리 작업 같은 것이 있습니다. 이 경우, 아래와 같은 과정을 거치게 됩니다.</p> <ol> <li>Redux 및 React Redux 라이브러리 설치</li> <li>액션 타입 및 액션 생성자 정의</li> <li>리듀서 만들기</li> <li>스토어 만들기</li> <li>컴포넌트에 Redux 연결하기</li> </ol> <p>다음과 같은 코드로 시작할 수 있습니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">redux</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Provider</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-redux</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nf">createStore</span><span class="p">(</span><span class="nx">reducer</span><span class="p">);</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Provider</span> <span class="na">store</span><span class="p">=</span><span class="si">{</span><span class="nx">store</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">MyRootComponent</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Provider</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>이처럼, React Native는 자바스크립트를 이용해 네이티브 모바일 앱을 개발할 수 있는 강력한 도구입니다. 그리고 우리는 이를 통해 크로스 플랫폼 모바일 앱 개발을 손쉽게 자율화할 수 있습니다. 하지만 이 기법이 만능은 아닙니다. 항상 앱의 특성과 성능 요구사항을 고려해야합니다. 그럼 시작해보세요!</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="react-native"/><summary type="html"><![CDATA[React Native를 이용해 본격 크로스 플랫폼 모바일 앱 개발에 도전하기]]></summary></entry><entry><title type="html">Immer로 React와 Redux에서 불변성을 쉽게 관리하며 코드 품질 높이기</title><link href="https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C-react%EC%99%80-redux%EC%97%90%EC%84%9C-immer%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%B6%88%EB%B3%80%EC%84%B1-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-immer%EB%A1%9C-react%EC%99%80-redux%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%A9%B0-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%EB%86%92%EC%9D%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Immer로 React와 Redux에서 불변성을 쉽게 관리하며 코드 품질 높이기"/><published>2025-05-04T07:29:45+00:00</published><updated>2025-05-04T07:29:45+00:00</updated><id>https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C:-react%EC%99%80-redux%EC%97%90%EC%84%9C-immer%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%B6%88%EB%B3%80%EC%84%B1-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-immer%EB%A1%9C-react%EC%99%80-redux%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%A9%B0-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%EB%86%92%EC%9D%B4%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/%EC%A3%BC%EC%A0%9C-react%EC%99%80-redux%EC%97%90%EC%84%9C-immer%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%B6%88%EB%B3%80%EC%84%B1-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-immer%EB%A1%9C-react%EC%99%80-redux%EC%97%90%EC%84%9C-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%A9%B0-%EC%BD%94%EB%93%9C-%ED%92%88%EC%A7%88-%EB%86%92%EC%9D%B4%EA%B8%B0/"><![CDATA[<h1 id="immer로-react와-redux에서-불변성을-쉽게-관리하며-코드-품질-높이기">Immer로 React와 Redux에서 불변성을 쉽게 관리하며 코드 품질 높이기</h1> <hr/> <p>React와 Redux에서 상태를 관리할 때, 우리는 불변성(Immutability)이 매우 중요하다는 사실을 알게 됩니다. 불변성이란, 데이터가 한번 생성되면 그 이후로는 변경되지 않는, 바꿀 수 없는 속성을 말합니다. React와 Redux의 상태는 불변성을 지켜주는 것이 중요하며, 이를 위해 불변성을 쉽게 관리해주는 라이브러리인 ‘Immer’를 사랑하는 개발자들이 많습니다.</p> <h2 id="불변성과-immer">불변성과 Immer</h2> <p>Immer는 상태 업데이트 로직을 매우 단순하게 만들어줍니다. 일반적으로 JavaScript에서 객체를 복사하거나 배열에 뭔가를 추가하는 등의 작업은 불변성을 지키기 위해 복잡한 코드를 작성해야 합니다. 하지만 Immer를 사용하면 이러한 불편함이 사라집니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">produce</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">immer</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">baseState</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">todo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Learn typescript</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">done</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="na">todo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Try immer</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">done</span><span class="p">:</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">];</span>

<span class="kd">const</span> <span class="nx">nextState</span> <span class="o">=</span> <span class="nf">produce</span><span class="p">(</span><span class="nx">baseState</span><span class="p">,</span> <span class="nx">draftState</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">draftState</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span><span class="na">todo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Tweet about it</span><span class="dl">"</span><span class="p">});</span>
  <span class="nx">draftState</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">});</span>

</code></pre></div></div> <p>위 코드에서 produce 함수는 첫번째 인자로 상태 객체(baseState), 두번째 인자로 변경을 수행하는 함수(draftState =&gt; { … })를 받습니다. 변경을 수행하는 함수에서 복잡한 작업을 수행하더라도, Immer의 produce 함수는 이를 자동으로 불변성을 지키면서 처리해줍니다.</p> <h2 id="실무에서-활용하기">실무에서 활용하기</h2> <p>아래는 Redux(또는 React-Redux)에서 action에 따라 state를 어떻게 업데이트할지 정의하는 리듀서 코드 예제입니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">produce</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">immer</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">todos</span><span class="p">(</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">produce</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="na">ADD_TODO</span><span class="p">:</span>
        <span class="nx">draft</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span> <span class="na">text</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="na">TOGGLE_TODO</span><span class="p">:</span>
        <span class="nx">draft</span><span class="p">[</span><span class="nx">action</span><span class="p">.</span><span class="nx">index</span><span class="p">].</span><span class="nx">done</span> <span class="o">=</span> <span class="o">!</span><span class="nx">draft</span><span class="p">[</span><span class="nx">action</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">done</span><span class="p">];</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="c1">// ... 추가 액션 핸들러</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

</code></pre></div></div> <p>위 예제에서 리듀서는 immer의 produce를 사용하고, action 종류에 따라서 변경할 state의 값을 직접 수정하고 있습니다. 이러한 방식으로 코드를 작성하면 불변성을 해치는 위험 없이, 쉽고 간결하게 상태를 업데이트할 수 있습니다. 이로 인해 코드의 유지보수성과 가독성 또한 향상됩니다.</p> <h2 id="응용-사례">응용 사례</h2> <p>Immer는 너무나도 간편하게 사용할 수 있으니, 가변 데이터에 대한 복잡한 로직을 단순화하는 등의 다양한 방식으로 응용이 가능합니다. 예를 들면, 중첩된 객체의 상태를 변경하는 등 복잡한 상태 업데이트가 필요한 경우 아래와 같이 사용할수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">const</span> <span class="nx">baseState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">object1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">object2</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">nextState</span> <span class="o">=</span> <span class="nf">produce</span><span class="p">(</span><span class="nx">baseState</span><span class="p">,</span> <span class="nx">draftState</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">draftState</span><span class="p">.</span><span class="nx">object1</span><span class="p">.</span><span class="nx">object2</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>

</code></pre></div></div> <p>결과적으로, 복잡한 상태 업데이트 로직에서도 Immutable하게 상태를 변경하는 것이 가능합니다. 이로 인해 코드의 복잡성을 크게 줄일 수 있습니다.</p> <h2 id="결론">결론</h2> <p>Immer란 라이브러리는 사용법이 간단하면서도, 불변성을 보장하는데 큰 편리함을 줍니다. 이렇게 간단하면서도 강력한 도구를 활용하여 품질 좋은 코드를 작성해보는 것은 어떨까요? Immer를 활용한 불변성 관리는 코드의 유지보수성과 가독성을 높이며, 여러분의 개발 경험을 훨씬 더 유쾌하게 할 것입니다.</p> <p>이번 글을 통해 react와 redux에서 Immer를 활용한 불변성 관리 기법을 알게 되었다면, 여러분의 프로젝트에도 적용해보시기를 권장드립니다. 일상적인 개발에서도 이러한 기법들을 적극 활용하면 효율적이고 안정적인 코드를 작성하는 데 큰 도움이 될 것입니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="immer"/><summary type="html"><![CDATA[Immer로 React와 Redux에서 불변성을 쉽게 관리하며 코드 품질 높이기]]></summary></entry><entry><title type="html">React에서 GraphQL과 Apollo를 활용한 첨단 데이터 관리 방법</title><link href="https://sungrinhan.github.io/blog/2025/graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%B2%A8%EB%8B%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="React에서 GraphQL과 Apollo를 활용한 첨단 데이터 관리 방법"/><published>2025-05-03T10:24:42+00:00</published><updated>2025-05-03T10:24:42+00:00</updated><id>https://sungrinhan.github.io/blog/2025/graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react%EC%97%90%EC%84%9C-graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%B2%A8%EB%8B%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-graphql%EA%B3%BC-apollo%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%B2%A8%EB%8B%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95/"><![CDATA[<h1 id="react에서-graphql과-apollo를-활용한-첨단-데이터-관리-방법">React에서 GraphQL과 Apollo를 활용한 첨단 데이터 관리 방법</h1> <h2 id="graphql이란">GraphQL이란?</h2> <p>GraphQL은 Facebook에서 2015년에 공개한 데이터 질의어 언어로, 클라이언트가 필요로 하는 데이터 구조를 명시하고 서버에 요청할 수 있도록 합니다. 즉, 클라이언트가 원하는 데이터만 골라서 가져올 수 있게 해주는 강력한 API 디자인 패러다임입니다.</p> <p>RESTful API에 비해 다양한 상황에 유연하게 대처가 가능하다는 장점이 있습니다. 특히, 단일 요청으로 여러 자원을 한 번에 가져올 수 있고, 클라이언트에서 필요한 필드만 선택해서 가져올 수 있으므로 데이터 과다 전송을 최소화할 수 있습니다.</p> <h2 id="apollo란">Apollo란?</h2> <p>Apollo는 GraphQL 클라이언트로, 앱 내부의 모든 데이터를 중앙에서 관리할 수 있게 도와줍니다. 예를 들어, 웹 브라우저에서 작동하는 JavaScript 앱에서는 Apollo Client가 이 역할을 합니다.</p> <p>Apollo는 많은 기능을 제공하는데, 인-메모리 캐시, 확장 가능한 로컬 상태 관리, 서버 사이드 렌더링(SSR)지원, 에러 핸들링 등의 기능이 있습니다. 또한 GraphQL 쿼리치는 명령을 표준화해서, 애플리케이션의 데이터를 간편하게 가져오고 관리할 수 있도록 돕습니다.</p> <h2 id="실제-코드-예시">실제 코드 예시</h2> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">ApolloProvider</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@apollo/react-hooks</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">ApolloClient</span><span class="p">,</span> <span class="nx">InMemoryCache</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@apollo/client</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Posts</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./Posts</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ApolloClient</span><span class="p">({</span>
  <span class="na">cache</span><span class="p">:</span> <span class="k">new</span> <span class="nc">InMemoryCache</span><span class="p">(),</span>
  <span class="na">uri</span><span class="p">:</span> <span class="dl">'</span><span class="s1">https://your-graphql-end-point</span><span class="dl">'</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">App</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">ApolloProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">client</span><span class="p">}</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Posts</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/ApolloProvider</span><span class="err">&gt;
</span><span class="p">);</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</code></pre></div></div> <p>위 코드에서 Apollo Client는 GraphQL 서버에 대한 엔드포인트를 uri 프로퍼티에 지정해서 초기화됩니다. 그리고 이 클라이언트를 ApolloProvider로 감싸어 하위 컴포넌트에게 이 클라이언트를 공급합니다. 이렇게 하면 하위 컴포넌트에서는 이 Apollo 클라이언트를 이용해서 GraphQL 요청을 보낼 수 있게 됩니다.</p> <h2 id="실무에서-사용할-법한-예시-및-꿀팁">실무에서 사용할 법한 예시 및 꿀팁</h2> <p>GraphQL과 Apollo를 활용한 데이터 관리는 복잡한 데이터 구조와 큰 규모의 애플리케이션에서 특히 훌륭한 결과를 나타냅니다. 가령, 여러 리소스로부터 데이터를 집계하거나, 다른 리소스에 의존하는 데이터를 가져오는 경우에 굉장히 유용합니다.</p> <p>꿀팁으로는 Apollo에서 제공하는 캐시 기능을 잘 활용하는 것이 중요합니다. 데이터를 캐시하면 재요청 없이 즉시 데이터를 로드할 수 있고, 앱의 전체적인 성능이 향상됩니다. Apollo Client는 기본적으로 모든 요청을 캐시하고, 같은 요청이 다시 발생하면 네트워크를 통해 데이터를 가져오지 않고 캐시를 사용해서 결과를 반환합니다.</p> <h2 id="응용버전-예시">응용버전 예시</h2> <p>GraphQL과 Apollo를 사용하면 사용자 인터페이스를 기반으로 애플리케이션의 데이터를 모델링하고 관리하는 것이 쉽습니다. 이전 RESTful 방식과 달리 모든 데이터를 중앙에서 관리할 수 있으므로 데이터에 접근하거나 상태를 업데이트하는 작업이 단순화 되고, 평가도가 높은 사용자 경험을 제공할 수 있습니다.</p> <p>더 발전된 예시로는, Apollo Client 3.0부터 도입된 Apollo 로컬 상태 관리 기능을 활용하는 것입니다. 이를 통해 React의 Context API나 Redux 등 별도의 상태관리 라이브러리 없이도, Apollo만으로 전역 상태 관리가 가능합니다. 이를 활용하면 개발에 복잡성이 줄어들고 성능까지 향상할 수 있습니다.</p> <p>예를 들어 특정 사용자의 로그인 상태를 전역적으로 관리해야 하는 경우, 아래와 같이 코드를 작성해보면 됩니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">ApolloClient</span><span class="p">,</span> <span class="nx">gql</span><span class="p">,</span> <span class="nx">InMemoryCache</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@apollo/client</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ApolloClient</span><span class="p">({</span>
  <span class="na">cache</span><span class="p">:</span> <span class="k">new</span> <span class="nc">InMemoryCache</span><span class="p">(),</span> 
  <span class="na">uri</span><span class="p">:</span> <span class="dl">'</span><span class="s1">https://your-graphql-end-point</span><span class="dl">'</span><span class="p">,</span>
<span class="p">});</span>

<span class="nx">client</span><span class="p">.</span><span class="nf">writeQuery</span><span class="p">({</span>
  <span class="na">query</span><span class="p">:</span> <span class="nx">gql</span><span class="s2">`
    query GetUser {
      user
    }
  `</span><span class="p">,</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">user</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">__typename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">User</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">isLoggedIn</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div> <p>위 코드는 ‘GetUser’라는 쿼리에 대한 초기 데이터를 캐시에 작성하는 예시입니다. 이것을 통해 <code class="language-plaintext highlighter-rouge">user.isLoggedIn</code> 값을 전역적으로 관리하게 되며, 이 값을 이용해 로그인 상태에 따른 조건부 렌더링 등 다양한 활용이 가능하게 됩니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="graphql,apollo"/><summary type="html"><![CDATA[React에서 GraphQL과 Apollo를 활용한 첨단 데이터 관리 방법]]></summary></entry><entry><title type="html">React에서 TypeScript를 활용한 강력한 타입 관리 블로그 제목: React에서 TypeScript로 향상된 타입안정성과 코드 퀄리티 Realize하기</title><link href="https://sungrinhan.github.io/blog/2025/react%EC%97%90%EC%84%9C-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B0%95%EB%A0%A5%ED%95%9C-%ED%83%80%EC%9E%85-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-typescript%EB%A1%9C-%ED%96%A5%EC%83%81%EB%90%9C-%ED%83%80%EC%9E%85%EC%95%88%EC%A0%95%EC%84%B1%EA%B3%BC-%EC%BD%94%EB%93%9C-%ED%80%84%EB%A6%AC%ED%8B%B0-realize%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="React에서 TypeScript를 활용한 강력한 타입 관리 블로그 제목: React에서 TypeScript로 향상된 타입안정성과 코드 퀄리티 Realize하기"/><published>2025-04-30T15:43:07+00:00</published><updated>2025-04-30T15:43:07+00:00</updated><id>https://sungrinhan.github.io/blog/2025/react%EC%97%90%EC%84%9C-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B0%95%EB%A0%A5%ED%95%9C-%ED%83%80%EC%9E%85-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react%EC%97%90%EC%84%9C-typescript%EB%A1%9C-%ED%96%A5%EC%83%81%EB%90%9C-%ED%83%80%EC%9E%85%EC%95%88%EC%A0%95%EC%84%B1%EA%B3%BC-%EC%BD%94%EB%93%9C-%ED%80%84%EB%A6%AC%ED%8B%B0-realize%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/react%EC%97%90%EC%84%9C-typescript%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B0%95%EB%A0%A5%ED%95%9C-%ED%83%80%EC%9E%85-%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-typescript%EB%A1%9C-%ED%96%A5%EC%83%81%EB%90%9C-%ED%83%80%EC%9E%85%EC%95%88%EC%A0%95%EC%84%B1%EA%B3%BC-%EC%BD%94%EB%93%9C-%ED%80%84%EB%A6%AC%ED%8B%B0-realize%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="react에서-typescript로-향상된-타입안정성과-코드-퀄리티-realize하기">React에서 TypeScript로 향상된 타입안정성과 코드 퀄리티 Realize하기</h1> <h2 id="개념-설명">개념 설명</h2> <p>자바스크립트와 함께 몇 년 동안 개발한 후, TypeScript로 전환한 개발자들이 많습니다. TypeScript는 확장된 자바스크립트로, 자바스크립트에 정적 타입이 추가된 버전이라고 이해할 수 있습니다. 이는 오류를 더 쉽게 추적하고 부가적인 도구나 편집기 지원을 제공하기 위한 것입니다.</p> <p>TypeScript의 가장 큰 장점 중 하나는 강력한 타입 시스템입니다. 이는 코드의 품질과 가독성을 높이며, 런타임 오류를 줄이는 데 크게 기여합니다. 오늘날 React는 대표적인 프런트엔드 라이브러리로 사용되며, TypeScript와 함께 사용될 때 더욱 강력해집니다. React와 TypeScript를 함께 사용하면 props, state 및 이벤트 핸들러와 같이 널리 사용되는 React 요소의 타입을 명확하게 지정할 수 있어 코드의 전반적인 품질을 향상시킬 수 있습니다.</p> <h2 id="코드-예시">코드 예시</h2> <p>다음은 React와 TypeScript가 어떻게 함께 작동하는지 보여주는 간단한 예제입니다.</p> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="o">*</span> <span class="kd">as </span><span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">MyComponent</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
       <span class="p">{</span><span class="nx">name</span><span class="p">}</span> <span class="k">is</span> <span class="p">{</span><span class="nx">age</span><span class="p">}</span> <span class="nx">years</span> <span class="nx">old</span><span class="p">.</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 예제에서, 우리는 Props라는 TypeScript 인터페이스를 정의하고, 이 인터페이스를 MyComponent의 props로 사용하였습니다. 이러한 방식으로, 나중에 이 컴포넌트에 잘못된 타입의 props를 전달하려고 한다면 TypeScript는 에러를 발생시킵니다.</p> <h2 id="실무-활용-및-꿀팁">실무 활용 및 꿀팁</h2> <ul> <li>이벤트 핸들러에 타입을 정의하려면 React가 제공하는 SyntheticEvent 타입을 사용하세요. 예를 들면, 클릭 이벤트 핸들러를 정의하려면 다음과 같이 할 수 있습니다:</li> </ul> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">SyntheticEvent</span><span class="o">&lt;</span><span class="nx">HTMLButtonElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>TypeScript와 함께 라이브러리를 사용하려면 해당 라이브러리의 타입 정의를 설치해야 할 수도 있습니다. 대부분의 자바스크립트 라이브러리는 @types/ 패키지를 통해 타입을 제공합니다.</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> @types/react
</code></pre></div></div> <ul> <li>React 컴포넌트에 함수형 컴포넌트 형식을 사용하려면, TypeScript의 함수형 컴포넌트 정의를 사용하세요:</li> </ul> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Props</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">MyComponent</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">FC</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span> <span class="k">is</span> <span class="p">{</span><span class="nx">age</span><span class="p">}</span> <span class="nx">years</span> <span class="nx">old</span><span class="p">.</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div> <h2 id="응용버전-예시">응용버전 예시</h2> <p>React와 TypeScript를 사용하여 복잡한 상태 관리를 수행하는 간단한 예제를 살펴보겠습니다.</p> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">UserState</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">UserComponent</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="p">{},</span> <span class="nx">UserState</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="na">props</span><span class="p">:</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
      <span class="na">age</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">handleNameChange</span> <span class="o">=</span> <span class="p">(</span><span class="na">event</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">setState</span><span class="p">({</span><span class="na">name</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">value</span><span class="p">});</span>
  <span class="p">}</span>

  <span class="nx">handleAgeChange</span> <span class="o">=</span> <span class="p">(</span><span class="na">event</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">setState</span><span class="p">({</span><span class="na">age</span><span class="p">:</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">value</span><span class="p">)});</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return </span><span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
       <span class="o">&lt;</span><span class="nx">input</span> <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleNameChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>       <span class="o">&lt;</span><span class="nx">input</span> <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">number</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">age</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleAgeChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드는 name이라는 문자열과 age라는 숫자를 상태로 가지는 <code class="language-plaintext highlighter-rouge">UserComponent</code>를 정의하고 있습니다. 각각의 상태는 적절한 이벤트 핸들러를 통해 변경됩니다. 이벤트 핸들러의 인자로 들어오는 이벤트 객체 역시 적절한 타입으로 지정되어 있어, 다른 타입의 이벤트 객체가 들어온다면 컴파일 오류를 발생시킵니다. 이와 같이 React와 TypeScript를 함께 사용하면 코드의 타입 안정성을 높이고, 런타임 오류를 줄이는 데 큰 도움이 됩니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="React에서"/><summary type="html"><![CDATA[React에서 TypeScript로 향상된 타입안정성과 코드 퀄리티 Realize하기]]></summary></entry><entry><title type="html">React Hooks를 활용한 상태관리와 컴포넌트 생명주기 블로그 제목: React Hooks를 접속해서 상태 관리와 컴포넌트 생명주기를 한단계 더 알아보기</title><link href="https://sungrinhan.github.io/blog/2025/react-hooks%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-hooks%EB%A5%BC-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%A5%BC-%ED%95%9C%EB%8B%A8%EA%B3%84-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="React Hooks를 활용한 상태관리와 컴포넌트 생명주기 블로그 제목: React Hooks를 접속해서 상태 관리와 컴포넌트 생명주기를 한단계 더 알아보기"/><published>2025-04-29T07:07:56+00:00</published><updated>2025-04-29T07:07:56+00:00</updated><id>https://sungrinhan.github.io/blog/2025/react-hooks%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react-hooks%EB%A5%BC-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%A5%BC-%ED%95%9C%EB%8B%A8%EA%B3%84-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/react-hooks%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-hooks%EB%A5%BC-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EC%99%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%A5%BC-%ED%95%9C%EB%8B%A8%EA%B3%84-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<hr/> <p>layout: post title: “React Hooks를 활용한 상태관리와 컴포넌트 생명주기” date: 2021-06-30 desc: “React Hooks 사용법과 상태 관리, 컴포넌트 생명주기를 이해하고 실무에 활용해보자.” categories: [Development] tags: [React, Hooks, State Management] —</p> <p>React Hooks는 React의 16.8 버전 이후로 도입된 기능으로, 함수형 컴포넌트에서도 상태 정보를 가질 수 있게 만들어주며 생명주기 훅을 함수형 컴포넌트에서도 사용할 수 있게 해준다. 이전에는 클래스 컴포넌트에서만 가능했던 이런 작업을 Hooks를 사용해서 함수형 컴포넌트에서도 할 수 있게 되었다.</p> <p>React의 기본 제공 Hook에는 <code class="language-plaintext highlighter-rouge">useState</code>, <code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useContext</code> 등이 있다. 각각의 Hook은 상태 관리와 생명주기, 그리고 context API를 활용한 글로벌 상태 관리를 지원한다.</p> <h4 id="usestate">useState</h4> <p>먼저, <code class="language-plaintext highlighter-rouge">useState</code>는 가장 기본적인 상태 관리 Hook이다. 다음은 <code class="language-plaintext highlighter-rouge">useState</code>를 사용하는 간단한 예제다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>You clicked <span class="si">{</span><span class="nx">count</span><span class="si">}</span> times<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
        Click me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>위 예제는 count라는 상태 값을 관리하고, 버튼 클릭 시 count 값을 1씩 증가시키는 기능을 하는 컴포넌트다. <code class="language-plaintext highlighter-rouge">useState</code> 함수는 인자로 초기 상태 값을 받고, 배열을 반환하는데 첫 번째 원소는 현재 상태 값, 두 번째 원소는 해당 상태를 갱신하는 함수다.</p> <p>꿀팁으로는, 상태 값이 복잡한 객체나 배열일 경우 <code class="language-plaintext highlighter-rouge">setCount</code> 함수를 사용할 때 이전 상태 값에 기반하여 업데이트를 해야한다면 함수를 인자로 넣어줄 수 있다는 점이다. 이렇게 하면 React가 알아서 이전 상태 값을 넣어 호출해준다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">setCount</span><span class="p">(</span><span class="nx">prevCount</span> <span class="o">=&gt;</span> <span class="nx">prevCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <h4 id="useeffect">useEffect</h4> <p><code class="language-plaintext highlighter-rouge">useEffect</code> 는 컴포넌트가 렌더링된 이후에 어떤 작업을 수행해야 하는지 정의할 수 있다. 이를 통해 <code class="language-plaintext highlighter-rouge">componentDidMount</code>, <code class="language-plaintext highlighter-rouge">componentDidUpdate</code>, <code class="language-plaintext highlighter-rouge">componentWillUnmount</code> 와 같은 생명주기 함수를 사용할 수 있다.</p> <p>실제 예제를 살펴보자.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="s2">`You clicked </span><span class="p">${</span><span class="nx">count</span><span class="p">}</span><span class="s2"> times`</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>You clicked <span class="si">{</span><span class="nx">count</span><span class="si">}</span> times<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
        Click me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>위 예제는 <code class="language-plaintext highlighter-rouge">useEffect</code> 를 통해 브라우저의 문서 제목을 변경하는 부수 효과(side effect)를 수행한다.</p> <p>마지막으로, 커스텀 Hook을 만들어 재사용 가능한 로직을 제작할 수 있다. 아래 코드는 특정 URL에 대한 API 요청 결과를 반환하는 커스텀 Hook인 <code class="language-plaintext highlighter-rouge">useFetch</code>를 만드는 예제다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">useFetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">loading</span><span class="p">,</span> <span class="nx">setLoading</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  
  <span class="k">async</span> <span class="kd">function</span> <span class="nf">fetchUrl</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
    
    <span class="nf">setData</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
    <span class="nf">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">fetchUrl</span><span class="p">();</span>
  <span class="p">},</span> <span class="p">[]);</span>
  
  <span class="k">return</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">loading</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <p>위와 같이 개발자가 필요로 하는 로직을 커스텀 Hook으로 만들어 재사용하면 코딩을 더 효율적이고 일관성 있게 작성할 수 있다. 처음 Hook을 접하는 개발자라면 익숙해질 때까지 공식 레퍼런스를 뒤져보고, 기존의 클래스 컴포넌트를 함수형 컴포넌트로 바꿔보는 연습을 해보는 것을 추천한다.</p> <p>이상이다. Happy Coding!</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="React"/><summary type="html"><![CDATA[layout: post title: “React Hooks를 활용한 상태관리와 컴포넌트 생명주기” date: 2021-06-30 desc: “React Hooks 사용법과 상태 관리, 컴포넌트 생명주기를 이해하고 실무에 활용해보자.” categories: [Development] tags: [React, Hooks, State Management] —]]></summary></entry><entry><title type="html">React-Router를 이용한 싱글 페이지 어플리케이션 구현 블로그 제목: React-Router 활용 가이드: 싱글 페이지 어플리케이션 구현하기</title><link href="https://sungrinhan.github.io/blog/2025/react-router%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-router-%ED%99%9C%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="React-Router를 이용한 싱글 페이지 어플리케이션 구현 블로그 제목: React-Router 활용 가이드: 싱글 페이지 어플리케이션 구현하기"/><published>2025-04-27T10:46:25+00:00</published><updated>2025-04-27T10:46:25+00:00</updated><id>https://sungrinhan.github.io/blog/2025/react-router%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react-router-%ED%99%9C%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C:-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/react-router%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react-router-%ED%99%9C%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="react-router-활용-가이드-싱글-페이지-어플리케이션-구현하기">React-Router 활용 가이드: 싱글 페이지 어플리케이션 구현하기</h1> <p>React-Router는 React를 함께 사용할 수 있도록 설계된 유연하고 강력한 라우팅 라이브러리입니다. 클라이언트 사이드 라우팅을 지원함으로써 페이지 간의 이동이 서버와의 새로운 요청 없이 이루어지는 싱글 페이지 어플리케이션을 구축하기에 최적화되어 있습니다.</p> <p>React-Router는 URL의 변화를 감지하고 URL에 따라 다른 컴포넌트를 렌더합니다. 이에 따라 사용자는 페이지를 새로고침하지 않고도 애플리케이션의 다른 부분을 볼 수 있습니다. 이것이 싱글 페이지 어플리케이션의 중요한 특성인데요, 이를 통해 사용자 경험은 획기적으로 향상됩니다.</p> <p>이해를 돕기 위해 간단한 코드 예시를 살펴봅시다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">ReactDOM</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-dom</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserRouter</span> <span class="nx">as</span> <span class="nx">Router</span><span class="p">,</span> <span class="nx">Route</span><span class="p">,</span> <span class="nx">Switch</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-router-dom</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Router</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Switch</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">exact</span> <span class="na">path</span><span class="p">=</span><span class="s">"/"</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">Home</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Route</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/about"</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">About</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Route</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Switch</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Router</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">About</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>About<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="nx">ReactDOM</span><span class="p">.</span><span class="nf">render</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="p">/&gt;,</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">root</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div></div> <p>위 예시에서 <code class="language-plaintext highlighter-rouge">BrowserRouter</code> 컴포넌트는 라우터로서의 기능을 제공하며, 앱의 최상위 컴포넌트로 위치해야 합니다. <code class="language-plaintext highlighter-rouge">Switch</code> 컴포넌트는 여러 <code class="language-plaintext highlighter-rouge">Route</code> 중 단 한개의 <code class="language-plaintext highlighter-rouge">Route</code>만을 렌더하게 합니다. 여기서 <code class="language-plaintext highlighter-rouge">Route</code>의 <code class="language-plaintext highlighter-rouge">path</code>는 URL 경로를, <code class="language-plaintext highlighter-rouge">component</code>는 해당 경로에 렌더될 컴포넌트를 명시합니다. 그래서 <code class="language-plaintext highlighter-rouge">/</code> 경로에선 <code class="language-plaintext highlighter-rouge">Home</code> 컴포넌트가, <code class="language-plaintext highlighter-rouge">/about</code> 경로에선 <code class="language-plaintext highlighter-rouge">About</code> 컴포넌트가 렌더됩니다.</p> <p>실무에서는 페이지 규모가 훨씬 크기 때문에 라우터 구조를 보다 체계적으로 관리해야 합니다. 이럴 때 사용하는 패턴 중 하나는 각 페이지 별로 별도의 디렉터리를 두고 이 안에 해당 페이지에서만 쓰이는 컴포넌트와 페이지 컴포넌트를 함께 둡니다. 이렇게 하면 페이지 관련 코드를 한 곳에서 관리할 수 있어 유지보수에 유리합니다.</p> <p>더욱 응용하려면 비동기 로딩이 가능한 코드 스플리팅을 통해 초기 로딩 시간을 줄일 수 있습니다. React-Router는 <code class="language-plaintext highlighter-rouge">React.lazy</code>와 함께 사용할 수 있어 이를 활용하면 상황에 따라 필요한 코드만 로드할 수 있습니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Suspense</span><span class="p">,</span> <span class="nx">lazy</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserRouter</span> <span class="nx">as</span> <span class="nx">Router</span><span class="p">,</span> <span class="nx">Route</span><span class="p">,</span> <span class="nx">Switch</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-router-dom</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Home</span> <span class="o">=</span> <span class="nf">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">"</span><span class="s2">./routes/Home</span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">About</span> <span class="o">=</span> <span class="nf">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">"</span><span class="s2">./routes/About</span><span class="dl">"</span><span class="p">));</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Router</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Switch</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">exact</span> <span class="na">path</span><span class="p">=</span><span class="s">"/"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">Home</span><span class="si">}</span> <span class="p">/&gt;</span>
          <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/about"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">About</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Switch</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Router</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</code></pre></div></div> <p>단, 위와 같이 비동기 로딩을 사용하면 JS 번들이 분리되어 네트워크 요청이 추가로 발생하므로, 사용자가 방문할 확률이 높은 중요한 페이지는 코드 스플리팅을 적용하지 않는 것이 좋습니다. 이를 통해 초기 로딩 속도를 향상시킬 수 있습니다.</p> <p>이처럼 React-Router는 싱글 페이지 어플리케이션을 효과적으로 구현할 수 있도록 도와줍니다. 다만 강력한 도구임에도 불구하고, 그 이면에는 복잡한 고려사항들이 있습니다. 이에 적절한 아키텍처와 섬세한 코드 조직을 통해 이를 극복할 수 있습니다. 이 글을 통해 React-Router의 기능을 이해하고 이를 활용한 싱글 페이지 어플리케이션 구현에 한발짝 가까이 다가가셨길 바랍니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="React-Router"/><summary type="html"><![CDATA[React-Router 활용 가이드: 싱글 페이지 어플리케이션 구현하기]]></summary></entry><entry><title type="html">프론트엔드 테스트 기법과 Jest 블로그 제목: React에서 Jest를 활용한 프론트엔드 테스트 기법 마스터하기</title><link href="https://sungrinhan.github.io/blog/2025/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95%EA%B3%BC-jest-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-jest%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="프론트엔드 테스트 기법과 Jest 블로그 제목: React에서 Jest를 활용한 프론트엔드 테스트 기법 마스터하기"/><published>2025-04-26T11:43:29+00:00</published><updated>2025-04-26T11:43:29+00:00</updated><id>https://sungrinhan.github.io/blog/2025/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95%EA%B3%BC-jest-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-react%EC%97%90%EC%84%9C-jest%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95%EA%B3%BC-jest-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-react%EC%97%90%EC%84%9C-jest%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B2%95-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0/"><![CDATA[<hr/> <p>layout: post title: “React에서 Jest를 활용한 프론트엔드 테스트 기법 마스터하기” —</p> <h2 id="프론트엔드-테스트-jest를-활용하자">프론트엔드 테스트: Jest를 활용하자</h2> <p>프론트엔드 테스트는 그 어느때보다 중요해졌습니다. 특히, 리액트와 같은 modern UI 라이브러리의 복잡성이 증가함에 따라 테스트의 중요성 역시 매우 높아졌습니다. 이제는 단순히 돔 조작을 이외에도 상태 관리, 비동기 요청 등 복잡한 기능을 관리해야하므로, 적절한 단위 또는 통합 테스트는 높은 품질의 프론트엔드 애플리케이션 개발의 핵심 요소입니다.</p> <p>최근에 자바스크립트 테스트 도구로서 많이 쓰이고 있는 것이 Jest입니다. Jest는 Facebook이 오픈소스로 제공하는 자바스크립트 테스팅 프레임워크로, 간단하게 설치하고 설정할 수 있으며, 매우 빠르고 유연한 API를 제공함으로써 테스트 작성을 쉽게 해주는 장점이 있습니다.</p> <h3 id="jest-기본-예시">Jest: 기본 예시</h3> <p>Jest를 이용하여 기본적인 테스트 코드를 작성해보겠습니다. Jest에서는 테스트를 <code class="language-plaintext highlighter-rouge">it</code> 또는 <code class="language-plaintext highlighter-rouge">test</code> 함수로 작성합니다.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sum.js</span>
<span class="kd">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">;</span>

<span class="c1">// sum.test.js</span>
<span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./sum</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">test</span><span class="p">(</span><span class="dl">'</span><span class="s1">sums up two values</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)).</span><span class="nf">toBe</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>위 예시에서 볼 수 있듯이, Jest 테스트는 아주 직관적입니다. <code class="language-plaintext highlighter-rouge">expect</code> 함수로 어떤 값을 입력하면, <code class="language-plaintext highlighter-rouge">.toBe</code> 메서드를 이용하여 그 값이 기대하는 값과 같은지를 확인할 수 있습니다.</p> <h3 id="실무에서-사용할-법한-예시-및-꿀팁">실무에서 사용할 법한 예시 및 꿀팁</h3> <p>단순한 함수의 경우 위와 같이 테스트를 작성하면 되지만, 실제 애플리케이션에서는 비동기적인 요청이나 side effect를 발생시키는 함수를 테스트해야 할 때가 많습니다. 이런 경우에는 Jest에서 제공하는 <code class="language-plaintext highlighter-rouge">mock</code> 기능을 이용하여 테스트를 작성하면 편합니다.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// api.js</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">getUserName</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="s2">`/users/</span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="c1">// api.test.js</span>
<span class="nx">jest</span><span class="p">.</span><span class="nf">mock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./api</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">getUserName</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./api</span><span class="dl">'</span><span class="p">);</span>

<span class="nf">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">calls fetch with the right args and returns the username</span><span class="dl">'</span><span class="p">,</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">getUserName</span><span class="p">.</span><span class="nf">mockResolvedValueOnce</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">getUserName</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nf">toBe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>위 코드 예시처럼 실무에서는 <code class="language-plaintext highlighter-rouge">jest.mock</code> 기능을 활용해 API 호출과 같은 비동기 작업들을 모의하고 이에 대한 반환값을 미리 설정함으로써 실제 API를 호출하지 않고도 테스트 코드를 작성할 수 있습니다. 이렇게 하면 테스트를 독립적으로 유지할 수 있으며, 네트워크 지연 등의 문제로 테스트가 실패하는 것을 방지할 수 있습니다.</p> <h3 id="응용-버전-예시">응용 버전 예시</h3> <p>Jest와 관련된 응용 버전으로는 <code class="language-plaintext highlighter-rouge">snapshot testing</code>이 있습니다. 이 방법은 React 컴포넌트의 출력값을 간편하게 테스트할 수 있도록 도와줍니다. <code class="language-plaintext highlighter-rouge">toMatchSnapshot</code> 함수를 이용해서, 처음 실행 시에는 스냅샷을 생성하고 이후 실행할 때는 이전 스냅샷과 비교하여 변동사항이 없는지 테스트합니다.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Link.react.test.js</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">renderer</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-test-renderer</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Link</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../Link.react</span><span class="dl">'</span><span class="p">;</span>

<span class="nf">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">renders correctly</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">renderer</span>
    <span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Link</span> <span class="nx">page</span><span class="o">=</span><span class="dl">"</span><span class="s2">http://www.facebook.com</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Facebook</span><span class="o">&lt;</span><span class="sr">/Link&gt;</span><span class="err">)
</span>    <span class="p">.</span><span class="nf">toJSON</span><span class="p">();</span>
  <span class="nf">expect</span><span class="p">(</span><span class="nx">tree</span><span class="p">).</span><span class="nf">toMatchSnapshot</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div> <p>Jest만 잘 이용하면 프론트엔드 테스트의 거의 모든 케이스를 커버할 수 있습니다. 기본적인 단위테스트부터 비동기 처리, 리액트 컴포넌트 테스트까지 다양한 테스트 케이스를 효율적으로 작성할 수 있으므로, Jest는 프론트엔드 개발자의 필수 도구로서 빠르게 자리잡고 있습니다. 매번 기능을 추가할 때마다 수동으로 확인하는 시대는 지났습니다. Jest와 같은 테스트 프레임워크를 이용하면, 기능을 추가하거나 변경할 때마다 코드가 올바르게 동작하는지 자동적으로 검증할 수 있습니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="프론트엔드"/><summary type="html"><![CDATA[layout: post title: “React에서 Jest를 활용한 프론트엔드 테스트 기법 마스터하기” —]]></summary></entry><entry><title type="html">Redux Toolkit을 활용한 효율적인 상태관리 블로그 제목: Redux Toolkit 활용: 쉽고 빠른 상태 관리를 위한 해법</title><link href="https://sungrinhan.github.io/blog/2025/redux-toolkit%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-redux-toolkit-%ED%99%9C%EC%9A%A9-%EC%89%BD%EA%B3%A0-%EB%B9%A0%EB%A5%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%95%B4%EB%B2%95/" rel="alternate" type="text/html" title="Redux Toolkit을 활용한 효율적인 상태관리 블로그 제목: Redux Toolkit 활용: 쉽고 빠른 상태 관리를 위한 해법"/><published>2025-04-24T13:32:39+00:00</published><updated>2025-04-24T13:32:39+00:00</updated><id>https://sungrinhan.github.io/blog/2025/redux-toolkit%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9:-redux-toolkit-%ED%99%9C%EC%9A%A9:-%EC%89%BD%EA%B3%A0-%EB%B9%A0%EB%A5%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%95%B4%EB%B2%95</id><content type="html" xml:base="https://sungrinhan.github.io/blog/2025/redux-toolkit%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%9C%EB%AA%A9-redux-toolkit-%ED%99%9C%EC%9A%A9-%EC%89%BD%EA%B3%A0-%EB%B9%A0%EB%A5%B8-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%95%B4%EB%B2%95/"><![CDATA[<p>블로그 내용:</p> <p>Redux Toolkit은 Redux의 ‘공식 방법’으로 사실상 Redux의 요구사항을 단순화 합니다. Redux Toolkit을 사용하면 당신은 액션 타입, 액션 생성자 함수, 리듀서 함수를 직접 작성할 필요가 없습니다. 대신 <code class="language-plaintext highlighter-rouge">createSlice()</code>라는 Redux Toolkit 함수를 사용하여 이 모든 것들을 한 번에 생성할 수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createSlice</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">counterSlice</span> <span class="o">=</span> <span class="nf">createSlice</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">counter</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">initialState</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="na">reducers</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">increment</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">decrement</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="k">export</span> <span class="kd">const</span> <span class="p">{</span> <span class="nx">actions</span><span class="p">,</span> <span class="nx">reducer</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">counterSlice</span>
</code></pre></div></div> <p>위의 코드에서 리듀서 함수는 더 이상 불변성을 직접 관리할 필요가 없습니다. Redux Toolkit은 ‘Immer’라는 라이브러리를 내부적으로 사용하여 불변성을 자동으로 처리합니다.</p> <p>이제 실무에서 어떻게 활용할 수 있을지 알아봅시다. Redux Toolkit은 비동기 작업 처리를 위한 <code class="language-plaintext highlighter-rouge">createAsyncThunk</code> 함수를 제공합니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createAsyncThunk</span><span class="p">,</span> <span class="nx">createSlice</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">fetchUserById</span> <span class="o">=</span> <span class="nf">createAsyncThunk</span><span class="p">(</span><span class="dl">'</span><span class="s1">users/fetchByIdStatus</span><span class="dl">'</span><span class="p">,</span> <span class="k">async </span><span class="p">(</span><span class="nx">userId</span><span class="p">,</span> <span class="nx">thunkAPI</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">axios</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">`/api/users/</span><span class="p">${</span><span class="nx">userId</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">usersSlice</span> <span class="o">=</span> <span class="nf">createSlice</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">users</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">initialState</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">reducers</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">extraReducers</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">fetchUserById</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">]:</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">[</span><span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">usersSlice</span><span class="p">.</span><span class="nx">reducer</span>
</code></pre></div></div> <p>위의 코드에서 <code class="language-plaintext highlighter-rouge">createAsyncThunk</code>는 Promise를 반환하는 함수를 인자로 받습니다. 이 함수 내에서는 서버로 데이터를 가져오거나, 저장하는 등의 비동기 작업을 처리하면 됩니다. 또한 <code class="language-plaintext highlighter-rouge">extraReducers</code>는 단일 액션 타입에 따라 여러 리듀서들을 실행할 수 있게 해줍니다.</p> <p>응용 버전을 살펴보면, 복잡한 상태 객체를 관리하는 상황에서도 Redux Toolkit을 효과적으로 활용할 수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createSlice</span><span class="p">,</span> <span class="nx">createAsyncThunk</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">fetchCommentsByPostId</span> <span class="o">=</span> <span class="nf">createAsyncThunk</span><span class="p">(</span><span class="dl">'</span><span class="s1">comments/fetchByPostIdStatus</span><span class="dl">'</span><span class="p">,</span> <span class="k">async </span><span class="p">(</span><span class="nx">postId</span><span class="p">,</span> <span class="nx">thunkAPI</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">axios</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">`/api/posts/</span><span class="p">${</span><span class="nx">postId</span><span class="p">}</span><span class="s2">/comments`</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">commentsSlice</span> <span class="o">=</span> <span class="nf">createSlice</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">comments</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">initialState</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">reducers</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">extraReducers</span><span class="p">:</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">fetchCommentsByPostId</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">]:</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">comment</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">state</span><span class="p">[</span><span class="nx">comment</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">comment</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">commentsSlice</span><span class="p">.</span><span class="nx">reducer</span>
</code></pre></div></div> <p>위의 코드에서는 포스트 ID로 댓글들을 가져와서 상태에 저장하는 시나리오를 보여줍니다. <code class="language-plaintext highlighter-rouge">fetchCommentsByPostId</code>라는 비동기 액션을 통해 서버에서 데이터를 가져온 후, 이를 상태에 반영하는 부분은 <code class="language-plaintext highlighter-rouge">extraReducers</code>를 통해 처리합니다.</p> <p>Redux Toolkit은 익히면 Redux 코드를 훨씬 더 간결하고 명확하게 만들 수 있는 도구입니다. 기본적인 사용법부터 비동기 작업 처리, 복잡한 상태 관리까지 쉽게 해결할 수 있으므로, 실무에서 많이 활용하게 될 것입니다.</p>]]></content><author><name></name></author><category term="프론트엔드"/><category term="Redux"/><summary type="html"><![CDATA[블로그 내용:]]></summary></entry></feed>